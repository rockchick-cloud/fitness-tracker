<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fitness Tracker</title>

    <!-- Tailwind via CDN so your existing className strings work -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React + ReactDOM (UMD builds) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel so we can write JSX right in this file -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      /* small helpers */
      .line-clamp-2{
        display:-webkit-box;
        -webkit-line-clamp:2;
        -webkit-box-orient:vertical;
        overflow:hidden;
      }
    </style>
  </head>

  <body class="bg-gradient-to-b from-white to-slate-50 min-h-screen">
    <div id="root"></div>

    <script type="text/babel">
      const { useEffect, useMemo, useRef, useState } = React;

      // ---------------------------
      // Tiny UI replacements (so we don't need shadcn/ui)
      // ---------------------------
      function Card({ className = "", children }) {
        return <div className={"bg-white border border-slate-200 " + className}>{children}</div>;
      }
      function CardHeader({ className = "", children }) {
        return <div className={"px-6 pt-5 " + className}>{children}</div>;
      }
      function CardContent({ className = "", children }) {
        return <div className={"px-6 pb-6 " + className}>{children}</div>;
      }
      function CardTitle({ className = "", children }) {
        return <div className={"text-lg font-semibold text-slate-900 " + className}>{children}</div>;
      }
      function Separator() {
        return <hr className="border-slate-200" />;
      }
      function Badge({ variant="outline", className="", children }) {
        const base = "inline-flex items-center gap-1 px-3 py-1 text-xs";
        const styles =
          variant === "secondary"
            ? "bg-slate-100 text-slate-800 border border-slate-200"
            : "bg-white text-slate-800 border border-slate-200";
        return <span className={[base, styles, className].join(" ")}>{children}</span>;
      }
      function Button({ variant="default", size="md", className="", disabled, title, onClick, children }) {
        const base = "inline-flex items-center justify-center font-medium transition";
        const sizes = size === "sm" ? "px-3 py-2 text-sm" : "px-4 py-2 text-sm";
        const styles =
          variant === "outline"
            ? "bg-white border border-slate-300 text-slate-900 hover:bg-slate-50"
            : variant === "secondary"
              ? "bg-slate-100 border border-slate-200 text-slate-900 hover:bg-slate-200"
              : "bg-slate-900 text-white hover:bg-slate-800";
        const dis = disabled ? "opacity-50 cursor-not-allowed" : "";
        return (
          <button
            className={[base, sizes, styles, "rounded-xl", className, dis].join(" ")}
            disabled={disabled}
            title={title}
            onClick={onClick}
            type="button"
          >
            {children}
          </button>
        );
      }
      function Progress({ value=0 }) {
        const v = Math.max(0, Math.min(100, value));
        return (
          <div className="w-full h-3 bg-slate-100 rounded-full overflow-hidden border border-slate-200">
            <div className="h-full bg-slate-900" style={{ width: v + "%" }} />
          </div>
        );
      }

      // Emoji ‚Äúicons‚Äù (because we‚Äôre avoiding libraries)
      const Icon = ({ name, className="" }) => {
        const map = {
          calendar: "üìÖ",
          check: "‚úÖ",
          clipboard: "‚òëÔ∏è",
          flame: "üî•",
          pause: "‚è∏Ô∏è",
          play: "‚ñ∂Ô∏è",
          reset: "üîÑ",
          timer: "‚è±Ô∏è",
          upload: "üì§",
          download: "üì•",
        };
        return <span className={className} aria-hidden="true">{map[name] || "‚Ä¢"}</span>;
      };

      // ---------------------------
      // Helpers
      // ---------------------------
      const pad2 = (n) => String(n).padStart(2, "0");
      const toISODateLocal = (d) =>
        `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`;

      const startOfDay = (d) => {
        const x = new Date(d);
        x.setHours(0, 0, 0, 0);
        return x;
      };

      const addDays = (d, n) => {
        const x = new Date(d);
        x.setDate(x.getDate() + n);
        return x;
      };

      const sameDay = (a, b) => toISODateLocal(a) === toISODateLocal(b);
      const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

      function nextSaturdayFrom(date) {
        const d = startOfDay(date);
        const dow = d.getDay(); // 0=Sun ... 6=Sat
        const delta = (6 - dow + 7) % 7;
        return addDays(d, delta === 0 ? 0 : delta);
      }

      // ---------------------------
      // Storage (compatible with older "Plank Tracker" keys)
      // ---------------------------
      const LS_KEYS = {
        legacyCompletedDates: "plankTracker.completedDates",
        legacyStreak: "plankTracker.streak",

        completedDates: "fitnessTracker.completedDates",
        longestStreak: "fitnessTracker.longestStreak",
        lastCompleted: "fitnessTracker.lastCompleted",
        totalCompleted: "fitnessTracker.totalCompleted",

        workoutLogByDate: "fitnessTracker.workoutLogByDate",
        startDateISO: "fitnessTracker.ui.startDateISO",
      };

      function readJSON(key, fallback) {
        try {
          const raw = localStorage.getItem(key);
          if (!raw) return fallback;
          return JSON.parse(raw);
        } catch {
          return fallback;
        }
      }

      function writeJSON(key, value) {
        try {
          localStorage.setItem(key, JSON.stringify(value));
        } catch {}
      }

      function mergeLegacyCompletedDates() {
        const legacy = readJSON(LS_KEYS.legacyCompletedDates, []);
        const current = readJSON(LS_KEYS.completedDates, []);
        const set = new Set([
          ...(Array.isArray(legacy) ? legacy : []),
          ...(Array.isArray(current) ? current : []),
        ]);
        const merged = Array.from(set).sort();
        writeJSON(LS_KEYS.completedDates, merged);
        return merged;
      }

      // ---------------------------
      // Workout schedule
      // ---------------------------
      const WEEK = [
        { day: "Saturday", plan: "Long Peloton Ride (60+ min)", category: "cycling" },
        { day: "Sunday", plan: "Yoga (20‚Äì30 min) + Walk (30 min)", category: "yoga" },
        { day: "Monday", plan: "Bike Bootcamp", category: "bootcamp" },
        { day: "Tuesday", plan: "Barre or Pilates (20 min) + Walk (30 min)", category: "barre" },
        { day: "Wednesday", plan: "Strength (30 min)", category: "strength" },
        { day: "Thursday", plan: "Core (10 min) + Pilates (10 min) + Walk or Jog (30 min)", category: "core" },
        { day: "Friday", plan: "Bike Bootcamp", category: "bootcamp" },
      ];

      const CATEGORY_COLORFUL = {
        cycling: "bg-emerald-50 text-emerald-800 border-emerald-200",
        yoga: "bg-indigo-50 text-indigo-800 border-indigo-200",
        bootcamp: "bg-orange-50 text-orange-800 border-orange-200",
        barre: "bg-pink-50 text-pink-800 border-pink-200",
        strength: "bg-slate-50 text-slate-800 border-slate-200",
        core: "bg-violet-50 text-violet-800 border-violet-200",
      };

      function categoryClass(category) {
        return CATEGORY_COLORFUL[category] || "bg-white text-slate-800 border-slate-200";
      }

      const DOW_TO_LABEL = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];

      function scheduleForDate(date) {
        const label = DOW_TO_LABEL[date.getDay()];
        return WEEK.find((x) => x.day === label) || WEEK[0];
      }

      // ---------------------------
      // Calendar
      // ---------------------------
      function buildMonthGrid(year, monthIndex) {
        const first = new Date(year, monthIndex, 1);
        const start = startOfDay(first);
        const firstDow = start.getDay();
        const gridStart = addDays(start, -firstDow);

        const days = [];
        for (let i = 0; i < 42; i++) days.push(addDays(gridStart, i));
        return { first, gridStart, days };
      }

      // ---------------------------
      // Streak calc
      // ---------------------------
      function computeLongestStreak(isoDates) {
        if (!isoDates || !isoDates.length) return 0;
        const dates = [...isoDates].sort();
        const dayNums = dates
          .map((iso) => Math.floor(new Date(iso + "T00:00:00").getTime() / 86400000))
          .filter((x) => Number.isFinite(x));

        let best = 1;
        let cur = 1;
        for (let i = 1; i < dayNums.length; i++) {
          if (dayNums[i] === dayNums[i - 1]) continue;
          if (dayNums[i] === dayNums[i - 1] + 1) {
            cur += 1;
            best = Math.max(best, cur);
          } else {
            cur = 1;
            best = Math.max(best, cur);
          }
        }
        return best;
      }

      // ---------------------------
      // Main App
      // ---------------------------
      function FitnessTrackerApp() {
        const [syncOpen, setSyncOpen] = useState(false);
        const [importText, setImportText] = useState("");
        const [syncMsg, setSyncMsg] = useState(null);

        const DURATION = 60;
        const [secondsLeft, setSecondsLeft] = useState(DURATION);
        const [running, setRunning] = useState(false);
        const intervalRef = useRef(null);

        const [completedDates, setCompletedDates] = useState([]);
        const [longestStreak, setLongestStreak] = useState(0);
        const [totalCompleted, setTotalCompleted] = useState(0);
        const [lastCompleted, setLastCompleted] = useState(null);

        const [workoutLogByDate, setWorkoutLogByDate] = useState({});
        const [startDateISO, setStartDateISO] = useState(null);

        const exportPayload = useMemo(() => ({
          v: 1,
          exportedAt: new Date().toISOString(),
          startDateISO,
          completedDates,
          longestStreak,
          totalCompleted,
          lastCompleted,
          workoutLogByDate,
        }), [startDateISO, completedDates, longestStreak, totalCompleted, lastCompleted, workoutLogByDate]);

        const exportAsText = useMemo(() => JSON.stringify(exportPayload), [exportPayload]);

        const copyExport = async () => {
          try {
            await navigator.clipboard.writeText(exportAsText);
            setSyncMsg("Copied your tracker data to clipboard.");
            setTimeout(() => setSyncMsg(null), 3000);
          } catch {
            setSyncMsg("Couldn‚Äôt copy automatically. Copy from the Export box manually.");
            setTimeout(() => setSyncMsg(null), 4000);
          }
        };

        const downloadExport = () => {
          try {
            const blob = new Blob([exportAsText], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `fitness-tracker-export-${toISODateLocal(new Date())}.json`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
            setSyncMsg("Downloaded export file.");
            setTimeout(() => setSyncMsg(null), 3000);
          } catch {
            setSyncMsg("Download failed. Copy/paste export text instead.");
            setTimeout(() => setSyncMsg(null), 4000);
          }
        };

        const applyImport = () => {
          setSyncMsg(null);
          let parsed;
          try { parsed = JSON.parse(importText); }
          catch {
            setSyncMsg("Import text isn‚Äôt valid.");
            setTimeout(() => setSyncMsg(null), 4000);
            return;
          }

          const incomingCompleted = Array.isArray(parsed?.completedDates) ? parsed.completedDates : [];
          const incomingWorkouts = parsed?.workoutLogByDate && typeof parsed.workoutLogByDate === "object" ? parsed.workoutLogByDate : {};
          const incomingStart = typeof parsed?.startDateISO === "string" ? parsed.startDateISO : null;

          const mergedCompleted = Array.from(new Set([...(completedDates || []), ...incomingCompleted])).sort();
          const mergedWorkouts = { ...(workoutLogByDate || {}), ...incomingWorkouts };

          setCompletedDates(mergedCompleted);
          setWorkoutLogByDate(mergedWorkouts);

          if (incomingStart) setStartDateISO(incomingStart);

          setTotalCompleted(mergedCompleted.length);
          setLastCompleted(mergedCompleted.length ? mergedCompleted[mergedCompleted.length - 1] : null);

          const effectiveStart = incomingStart || startDateISO;
          const filtered = effectiveStart ? mergedCompleted.filter((iso) => iso >= effectiveStart) : mergedCompleted;
          setLongestStreak(computeLongestStreak(filtered));

          setImportText("");
          setSyncMsg("Imported! Repeat export/import on the other device to match them.");
          setTimeout(() => setSyncMsg(null), 5000);
        };

        const today = useMemo(() => startOfDay(new Date()), []);
        const [viewYear, setViewYear] = useState(today.getFullYear());
        const [viewMonth, setViewMonth] = useState(today.getMonth());
        const [selectedISO, setSelectedISO] = useState(toISODateLocal(today));

        const monthGrid = useMemo(() => buildMonthGrid(viewYear, viewMonth), [viewYear, viewMonth]);

        const completedSet = useMemo(() => new Set(completedDates), [completedDates]);

        const startFilteredCompleted = useMemo(() => {
          if (!startDateISO) return completedDates;
          return (completedDates || []).filter((iso) => iso >= startDateISO);
        }, [completedDates, startDateISO]);

        const todaysISO = useMemo(() => toISODateLocal(today), [today]);
        const todaysSchedule = useMemo(() => scheduleForDate(today), [today]);
        const isCompletedToday = completedSet.has(todaysISO);

        const selectedDateObj = useMemo(() => startOfDay(new Date(selectedISO + "T00:00:00")), [selectedISO]);
        const selectedSchedule = useMemo(() => scheduleForDate(selectedDateObj), [selectedDateObj]);

        const selectedWorkoutLog = workoutLogByDate?.[selectedISO] || {
          completed: false, actual: "", minutes: "", notes: ""
        };

        useEffect(() => {
          const merged = mergeLegacyCompletedDates();
          setCompletedDates(merged);

          const lsLongest = readJSON(LS_KEYS.longestStreak, null);
          const legacyStreak = readJSON(LS_KEYS.legacyStreak, null);

          const lsTotal = readJSON(LS_KEYS.totalCompleted, null);
          const lsLast = readJSON(LS_KEYS.lastCompleted, null);

          const baselineLongest = Math.max(
            typeof legacyStreak === "number" ? legacyStreak : 0,
            typeof lsLongest === "number" ? lsLongest : 0
          );
          setLongestStreak(baselineLongest);

          const total = typeof lsTotal === "number" ? lsTotal : merged.length;
          setTotalCompleted(total);

          if (typeof lsLast === "string") setLastCompleted(lsLast);
          else if (merged.length) setLastCompleted(merged[merged.length - 1]);

          const workoutLog = readJSON(LS_KEYS.workoutLogByDate, {});
          setWorkoutLogByDate(workoutLog && typeof workoutLog === "object" ? workoutLog : {});

          const storedStartISO = readJSON(LS_KEYS.startDateISO, null);
          const defaultStartISO = toISODateLocal(nextSaturdayFrom(new Date()));
          const effectiveStart = typeof storedStartISO === "string" ? storedStartISO : defaultStartISO;
          setStartDateISO(effectiveStart);

          const startObj = startOfDay(new Date(effectiveStart + "T00:00:00"));
          setViewYear(startObj.getFullYear());
          setViewMonth(startObj.getMonth());
          setSelectedISO(effectiveStart);
        }, []);

        useEffect(() => writeJSON(LS_KEYS.completedDates, completedDates), [completedDates]);
        useEffect(() => writeJSON(LS_KEYS.longestStreak, longestStreak), [longestStreak]);
        useEffect(() => writeJSON(LS_KEYS.totalCompleted, totalCompleted), [totalCompleted]);
        useEffect(() => writeJSON(LS_KEYS.lastCompleted, lastCompleted), [lastCompleted]);
        useEffect(() => writeJSON(LS_KEYS.workoutLogByDate, workoutLogByDate), [workoutLogByDate]);
        useEffect(() => { if (startDateISO) writeJSON(LS_KEYS.startDateISO, startDateISO); }, [startDateISO]);

        useEffect(() => {
          if (!running) return;
          intervalRef.current = window.setInterval(() => {
            setSecondsLeft((s) => {
              const next = s - 1;
              if (next <= 0) {
                window.clearInterval(intervalRef.current);
                intervalRef.current = null;
                setRunning(false);
                return 0;
              }
              return next;
            });
          }, 1000);

          return () => {
            if (intervalRef.current) {
              window.clearInterval(intervalRef.current);
              intervalRef.current = null;
            }
          };
        }, [running]);

        const progress = useMemo(() => {
          const done = DURATION - secondsLeft;
          return Math.round((done / DURATION) * 100);
        }, [secondsLeft]);

        const currentStreak = useMemo(() => {
          if (!startFilteredCompleted.length) return 0;
          const sorted = [...startFilteredCompleted].sort();
          const set = new Set(sorted);

          let streak = 0;
          let cursor = startOfDay(new Date());
          const startObj = startDateISO ? startOfDay(new Date(startDateISO + "T00:00:00")) : null;

          if (!set.has(toISODateLocal(cursor))) cursor = addDays(cursor, -1);

          while (set.has(toISODateLocal(cursor))) {
            if (startObj && cursor < startObj) break;
            streak += 1;
            cursor = addDays(cursor, -1);
          }
          return streak;
        }, [startFilteredCompleted, startDateISO]);

        const workoutDoneCountThisMonth = useMemo(() => {
          const y = viewYear;
          const m = viewMonth;
          let count = 0;
          for (const [iso, v] of Object.entries(workoutLogByDate || {})) {
            if (startDateISO && iso < startDateISO) continue;
            const d = new Date(iso + "T00:00:00");
            if (d.getFullYear() === y && d.getMonth() === m && v?.completed) count += 1;
          }
          return count;
        }, [workoutLogByDate, viewYear, viewMonth, startDateISO]);

        const toggleRunning = () => {
          if (running) { setRunning(false); return; }
          if (secondsLeft <= 0) setSecondsLeft(DURATION);
          setRunning(true);
        };

        const resetTimer = () => {
          setRunning(false);
          setSecondsLeft(DURATION);
        };

        const markCompleteToday = () => {
          if (isCompletedToday) return;
          const next = Array.from(new Set([...(completedDates || []), todaysISO])).sort();
          setCompletedDates(next);

          setTotalCompleted((t) => Math.max(t, next.length));
          setLastCompleted(todaysISO);

          const filtered = startDateISO ? next.filter((iso) => iso >= startDateISO) : next;
          const longest = computeLongestStreak(filtered);
          setLongestStreak((prev) => Math.max(prev, longest));
        };

        const unmarkCompleteToday = () => {
          if (!isCompletedToday) return;
          const next = (completedDates || []).filter((x) => x !== todaysISO);
          setCompletedDates(next);
          setTotalCompleted((t) => Math.max(0, Math.min(t, next.length)));

          const filtered = startDateISO ? next.filter((iso) => iso >= startDateISO) : next;
          const longest = computeLongestStreak(filtered);
          setLongestStreak(longest);

          const last = next.length ? [...next].sort()[next.length - 1] : null;
          setLastCompleted(last);
        };

        const jumpToToday = () => {
          setViewYear(today.getFullYear());
          setViewMonth(today.getMonth());
          setSelectedISO(toISODateLocal(today));
        };

        const jumpToStart = () => {
          if (!startDateISO) return;
          const d = startOfDay(new Date(startDateISO + "T00:00:00"));
          setViewYear(d.getFullYear());
          setViewMonth(d.getMonth());
          setSelectedISO(startDateISO);
        };

        const prevMonth = () => {
          const d = new Date(viewYear, viewMonth, 1);
          d.setMonth(d.getMonth() - 1);
          setViewYear(d.getFullYear());
          setViewMonth(d.getMonth());
        };

        const nextMonth = () => {
          const d = new Date(viewYear, viewMonth, 1);
          d.setMonth(d.getMonth() + 1);
          setViewYear(d.getFullYear());
          setViewMonth(d.getMonth());
        };

        const headerMonthLabel = useMemo(() => {
          const d = new Date(viewYear, viewMonth, 1);
          return d.toLocaleString(undefined, { month: "long", year: "numeric" });
        }, [viewYear, viewMonth]);

        const timerLabel = `${Math.floor(secondsLeft / 60)}:${pad2(secondsLeft % 60)}`;

        const setWorkoutField = (field, value) => {
          setWorkoutLogByDate((prev) => {
            const next = { ...(prev || {}) };
            const cur = next[selectedISO] || { completed: false, actual: "", minutes: "", notes: "" };
            next[selectedISO] = { ...cur, [field]: value };
            return next;
          });
        };

        const toggleWorkoutComplete = () => {
          setWorkoutLogByDate((prev) => {
            const next = { ...(prev || {}) };
            const cur = next[selectedISO] || { completed: false, actual: "", minutes: "", notes: "" };
            next[selectedISO] = { ...cur, completed: !cur.completed };
            return next;
          });
        };

        const startDateLabel = useMemo(() => {
          if (!startDateISO) return null;
          const d = new Date(startDateISO + "T00:00:00");
          return d.toLocaleDateString(undefined, {
            weekday: "short", month: "short", day: "numeric", year: "numeric",
          });
        }, [startDateISO]);

        return (
          <div className="min-h-screen w-full bg-gradient-to-b from-white to-slate-50">
            <div className="mx-auto max-w-5xl px-4 py-8">
              <header className="mb-6 flex flex-col gap-2">
                <div className="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-3">
                  <div>
                    <h1 className="text-3xl font-semibold tracking-tight">Fitness Tracker</h1>
                    <p className="mt-1 text-sm text-slate-600">
                      Weekly plan + a simple 60-second daily plank challenge.
                    </p>
                    {startDateLabel ? (
                      <p className="mt-1 text-xs text-slate-600">
                        Tracking starts <span className="font-medium">{startDateLabel}</span> (your Saturday start).
                      </p>
                    ) : null}
                  </div>

                  <div className="flex flex-wrap items-center gap-2">
                    <Button variant="outline" size="sm" onClick={jumpToStart} title="Jump to your start date">
                      Start
                    </Button>

                    <Button
                      variant={syncOpen ? "default" : "outline"}
                      size="sm"
                      onClick={() => setSyncOpen((v) => !v)}
                      title="Move your data between phone + laptop"
                    >
                      <Icon name={syncOpen ? "upload" : "download"} className="mr-2" />
                      Sync
                    </Button>

                    <div className="hidden sm:flex items-center gap-2">
                      <Badge variant="outline" className="rounded-full">
                        <Icon name="flame" className="mr-1" /> Streak: {currentStreak}
                      </Badge>
                      <Badge variant="outline" className="rounded-full">
                        <Icon name="check" className="mr-1" /> Planks: {totalCompleted}
                      </Badge>
                      <Badge variant="outline" className="rounded-full">
                        <Icon name="clipboard" className="mr-1" /> Workouts this month: {workoutDoneCountThisMonth}
                      </Badge>
                    </div>
                  </div>
                </div>

                {syncOpen ? (
                  <div className="mt-4 rounded-2xl border bg-white p-4 shadow-sm">
                    <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-2">
                      <div>
                        <div className="text-sm font-medium">Sync between phone + laptop (no accounts needed)</div>
                        <div className="text-xs text-slate-600">
                          Export on one device ‚Üí paste/import on the other. A little manual, but it works.
                        </div>
                      </div>
                      {syncMsg ? (
                        <Badge variant="secondary" className="rounded-full">{syncMsg}</Badge>
                      ) : null}
                    </div>

                    <div className="mt-4 grid grid-cols-1 md:grid-cols-2 gap-4">
                      <div className="rounded-2xl border p-3">
                        <div className="flex items-center justify-between">
                          <div className="text-sm font-medium">Export</div>
                          <div className="flex gap-2">
                            <Button size="sm" onClick={copyExport}>
                              <Icon name="download" className="mr-2" /> Copy
                            </Button>
                            <Button size="sm" variant="outline" onClick={downloadExport}>
                              Download
                            </Button>
                          </div>
                        </div>
                        <textarea
                          value={exportAsText}
                          readOnly
                          className="mt-2 w-full min-h-[120px] rounded-xl border px-3 py-2 text-xs font-mono text-slate-700 outline-none"
                        />
                        <div className="mt-2 text-[11px] text-slate-600">
                          Tip: on iPhone, copying from the box works even if the Copy button is blocked.
                        </div>
                      </div>

                      <div className="rounded-2xl border p-3">
                        <div className="flex items-center justify-between">
                          <div className="text-sm font-medium">Import</div>
                          <Button size="sm" onClick={applyImport}>
                            <Icon name="upload" className="mr-2" /> Import
                          </Button>
                        </div>
                        <textarea
                          value={importText}
                          onChange={(e) => setImportText(e.target.value)}
                          placeholder="Paste export text here, then click Import"
                          className="mt-2 w-full min-h-[120px] rounded-xl border px-3 py-2 text-xs font-mono text-slate-700 outline-none focus:ring-2 focus:ring-slate-300"
                        />
                        <div className="mt-2 text-[11px] text-slate-600">
                          Import merges data (it won‚Äôt wipe what‚Äôs already on this device).
                        </div>
                      </div>
                    </div>
                  </div>
                ) : null}
              </header>

              <div className="grid grid-cols-1 gap-6 lg:grid-cols-3">
                <div className="lg:col-span-2 space-y-6">
                  <Card className="rounded-2xl shadow-sm">
                    <CardHeader className="pb-3">
                      <div className="flex items-center justify-between gap-2">
                        <CardTitle className="flex items-center gap-2">
                          <Icon name="calendar" className="mr-1" /> Workout Schedule
                        </CardTitle>
                        <Badge variant="secondary" className="rounded-full">
                          Today: {todaysSchedule.day}
                        </Badge>
                      </div>
                    </CardHeader>
                    <CardContent className="space-y-3">
                      <div className="space-y-2">
                        {WEEK.map((item) => {
                          const isToday = item.day === DOW_TO_LABEL[new Date().getDay()];
                          return (
                            <div
                              key={item.day}
                              className={`flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2 rounded-2xl border px-4 py-3 ${categoryClass(
                                item.category
                              )} ${isToday ? "ring-2 ring-slate-300" : ""}`}
                            >
                              <div className="flex items-center gap-2">
                                <div className="font-medium">{item.day}</div>
                                {isToday ? (
                                  <Badge className="rounded-full" variant="outline">
                                    Today
                                  </Badge>
                                ) : null}
                                <Badge variant="outline" className="rounded-full text-[10px]">
                                  {item.category}
                                </Badge>
                              </div>
                              <div className="text-sm opacity-90">{item.plan}</div>
                            </div>
                          );
                        })}
                      </div>

                      <Separator />

                      <div className="space-y-3">
                        <div className="flex flex-wrap items-center justify-between gap-2">
                          <div className="text-sm font-medium">{headerMonthLabel}</div>
                          <div className="flex items-center gap-2">
                            <Button variant="outline" size="sm" onClick={prevMonth}>Prev</Button>
                            <Button variant="outline" size="sm" onClick={jumpToToday}>Today</Button>
                            <Button variant="outline" size="sm" onClick={nextMonth}>Next</Button>
                          </div>
                        </div>

                        <div className="grid grid-cols-7 gap-2">
                          {DOW_TO_LABEL.map((d) => (
                            <div key={d} className="text-xs font-medium text-slate-500 px-1">
                              {d.slice(0, 3)}
                            </div>
                          ))}

                          {monthGrid.days.map((d, idx) => {
                            const inMonth = d.getMonth() === viewMonth;
                            const iso = toISODateLocal(d);
                            const plankDone = completedSet.has(iso);
                            const sch = scheduleForDate(d);
                            const isToday = sameDay(d, new Date());
                            const isSelected = iso === selectedISO;
                            const workoutDone = Boolean(workoutLogByDate?.[iso]?.completed);
                            const isBeforeStart = startDateISO ? iso < startDateISO : false;

                            return (
                              <button
                                type="button"
                                key={iso + idx}
                                onClick={() => setSelectedISO(iso)}
                                className={`text-left rounded-2xl border p-2 min-h-[104px] flex flex-col gap-1 transition hover:shadow-sm ${
                                  inMonth ? "bg-white" : "bg-slate-50"
                                } ${isToday ? "ring-2 ring-slate-300" : ""} ${
                                  isSelected ? "outline outline-2 outline-slate-400" : ""
                                } ${isBeforeStart ? "opacity-60" : ""}`}
                                title="Tap to log/check off this day"
                              >
                                <div className="flex items-center justify-between">
                                  <div className={`text-xs ${inMonth ? "text-slate-700" : "text-slate-400"}`}>
                                    {d.getDate()}
                                  </div>
                                  <div className="flex items-center gap-1">
                                    {workoutDone ? (
                                      <Badge variant="outline" className="rounded-full px-2 py-0 text-[10px]">
                                        W
                                      </Badge>
                                    ) : null}
                                    {plankDone ? <span title="Plank complete">‚úÖ</span> : null}
                                  </div>
                                </div>

                                <div
                                  className={`text-[11px] leading-snug line-clamp-2 rounded-xl border px-2 py-1 ${categoryClass(
                                    sch.category
                                  )}`}
                                  title={sch.plan}
                                >
                                  {sch.plan}
                                </div>

                                <div className="mt-auto text-[10px] text-slate-500">
                                  {plankDone ? "Plank ‚úì" : "Plank ‚Äî"} ‚Ä¢ {workoutDone ? "Workout ‚úì" : "Workout ‚Äî"}
                                </div>
                              </button>
                            );
                          })}
                        </div>

                        <p className="text-xs text-slate-600">
                          Tap a day to log what you did. ‚ÄúW‚Äù means workout checked off; checkmark means plank completed.
                        </p>
                      </div>
                    </CardContent>
                  </Card>

                  <Card className="rounded-2xl shadow-sm">
                    <CardHeader className="pb-3">
                      <CardTitle className="flex items-center gap-2">
                        <Icon name="timer" className="mr-1" /> Daily Challenge: 60-Second Plank
                      </CardTitle>
                    </CardHeader>
                    <CardContent className="space-y-5">
                      <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
                        <div className="space-y-2">
                          <div className="text-4xl font-semibold tabular-nums">{timerLabel}</div>
                          <Progress value={clamp(progress, 0, 100)} />
                          <div className="text-xs text-slate-600">Goal: 60 seconds. Breathe. Brace. Don‚Äôt shrug.</div>
                        </div>

                        <div className="flex flex-wrap gap-2">
                          <Button onClick={toggleRunning}>
                            <Icon name={running ? "pause" : "play"} className="mr-2" />
                            {running ? "Pause" : secondsLeft <= 0 ? "Restart" : "Start"}
                          </Button>
                          <Button variant="outline" onClick={resetTimer}>
                            <Icon name="reset" className="mr-2" /> Reset
                          </Button>
                        </div>
                      </div>

                      <Separator />

                      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
                        <div className="space-y-1">
                          <div className="flex items-center gap-2">
                            <Badge variant="outline" className="rounded-full">
                              <Icon name="flame" className="mr-1" /> Current streak: {currentStreak}
                            </Badge>
                            <Badge variant="outline" className="rounded-full">
                              Longest: {longestStreak}
                            </Badge>
                          </div>
                          <div className="text-xs text-slate-600">
                            Last completed: {lastCompleted ? new Date(lastCompleted).toLocaleDateString() : "‚Äî"}
                          </div>
                          {startDate
